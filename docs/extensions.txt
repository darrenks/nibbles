This is a list of ideas of things that are useless and could be remapped to something else (allowing for multi character builtins).

Only tracking things which take 2 nibbles to achieve.

available extensions (besides the tbd in quickref)
constant + constant (*) too
constant in loop
~ auto valued int (2 in *) (could mean infinity)
value at of a range (although depending on OOB behavior...)
opcode 15, mismatched 2d+ lists
debruijn index 7+ (tbd input)
many uses of num in extensions are actually int (many chr available)

unterminated int/str at end of program (or even partial string byte)

~first thing

list available
------------
filter filter
map map
length take n a = min n (length a)
take x drop y = drop y take x
reverse replicate = replicate reverse

diff a reverse b = diff a b
reverse .+ (etc) = .+ reverse
length .+ etc = length
map replicate = replicate map
map step = step map
map take = take map
map drop = drop map
subscript map = ; subscript
length replicate = * length
index replicate = index
replicate .* = .* replicate (but its 3 arg, need to work for other types too then it can be remapped to 2 arg, there's more like this)
rep rep = rep *
diff diff = diff :

num
====
+- = -+
// = */
** = * ... *
same for ++/min/etc

todo there's more


desired features
----------------
more vectorized (and both args list possible)
more special folds


bit ops (todo consider):
	2^
	shift left = *2^
	shift right = /2^
	bit at = .&. 2^
	not = 1-
	or = need
	and = need
	xor = need
	bits length = base / length
	rotate? = use array ops
	to/from str = to base + '0'
	popcount = make from base/sum

iterate = fold [infinite list] (not using $) (let's create it though)
unfold = iterate with takewhile/map
until = iterate with takeUntil
map accum = scan + ~ + map$

map [1..inf] # could have fn first (don't need)

prepend Nothing (skip for now)
chunk/while (add)
last/init (last = /@, init = \>~\ )
takeWhile (add, also would be first of split)
	takeWhile = assign, index_by, take $

group [by] (add)
transpose (add it)
array split, not removing empties (add it)
intercalate aka join = concat intersperse
intersperse = tail (concat map : ) (add)
list == = singleton index
list comparison < >, etc (don't need, could get from sort)
index by (add)
first by = first of filter
replace = split+join
count = length split - 1
uniq, setwise op [by] (add)
zipWith = map zip
zip prevs = zip dup tail (add)
zip index = zip nats

ljust/etc
downcase/upcase

chr ops:
replace chr 
split/join char
count chr
add int as a char

todo consider monads/seq/etc.

-- "too complicated"
sqrt
list of strs/ints shorthand (use 32+128 value of str?) (for ints leading 0 could meaning to take another int after)
permutations/combinations
iterate until fixed point / seen = last of map isUniq prefixes

------
to add
------
int
	bitwise xor / or / and | num -> num ->\
	could vectorize more ops if space | num -> any ->
	2** (auto 8) (if space) | int/num ->

list
	takeWhile / dropWhile / span | [any] -> fn ->
	splitAt | num -> [any] ->
	partition instead of filter?
	split, keep empties | [a] -> [a] ->
	intersperse | a -> [a] -> (intercalate could be useful too)
	group by
	indices [by]
	setwise uniq / xor / or / and (operate on first of tuples for [by]), keep multiples, that way can use uniq if don't want
	mapaccum
	==

str
	str= more useful than list=
	l/rjust (rjust more common in gs2)
	down/upcase (if room)
	tbd
	strip

chr
	tbd

misc
	autorec (base case and cond = $) (or maybe version) (skip for now.. how often really needed)
	nats (if needed...)

