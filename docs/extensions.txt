This is a list of ideas of things that are useless and could be remapped to something else (allowing for multi character builtins).

Only tracking things which take 2 nibbles to achieve.

available extensions (besides the tbd in quickref)
constant + constant (*) too
constant in loop
~ auto valued int (2 in *) (could mean infinity)
length of drop/take? not if they weren't as long as the int, although could be as short with 1 op min (todo)
value at of a range (although depending on OOB behavior...)
commutative/associative
opcode 15, mismatched 2d+ lists
debruijn index 7+ (tbd input)
many uses of num in extensions are actually int (many chr available)

unterminated int/str at end of program (or even partial string byte)

~ in toplevel (space or newline? or something in context)
	could have it mean: set separator to custom value (used for both input and output)

desired features
----------------
min/max - commutative +/* (todo)
not - don't need
and - * (if both pos) ^b ,a ... for lists: implicit >>= 
or - + (if both pos), :,a,b ... for lists: :
more vectorized ops (- / %) - don't need (for now)
more special folds - don't need (for now)
something to convert to truthiness (don't need?)
empty str, empty list of various types (don't need for now)

bit ops (todo consider):
	2^
	shift left = *2^
	shift right = /2^
	bit at = .&. 2^
	not = 1-
	or = need
	and = need
	xor = need
	bits length = base / length
	rotate? = use array ops
	to/from str = to base + '0'
	popcount = make from base/sum

iterate = fold [infinite list] (not using $) (let's create it though)
unfold = iterate with takewhile/map
until = iterate with takeUntil
map accum = scan + ~ + map$

map [1..inf] # could have fn first (don't need)

prepend Nothing (skip for now)
chunk/while (add)
last/init (last = /@, init = \>~\ )
takeWhile (add, also would be first of split)
	takeWhile = assign, index_by, take $

group [by] (add)
transpose (add it)
array split, not removing empties (add it)
intercalate aka join = concat intersperse
intersperse = tail (concat map : ) (add)
list == = singleton index
list comparison < >, etc (don't need, could get from sort)
index by (add)
first by = first of filter
replace = split+join
count = length split - 1
uniq, setwise op [by] (add)
zipWith = map zip
zip prevs = zip dup tail (add)
zip index = zip nats

ljust/etc
downcase/upcase

chr ops:
replace chr 
split/join char
count chr
add int as a char

todo consider monads/seq/etc.

-- "too complicated"
sqrt
list of strs/ints shorthand (use 32+128 value of str?) (for ints leading 0 could meaning to take another int after)
permutations/combinations
prefixes/suffixes = foldr [] : (but not so eloquently)
iterate until fixed point / seen = last of map isUniq prefixes

------
to add
------
any any

int
	bitwise xor / or / and | num -> num ->
	to base / from base | num -> num -> \ num -> [num] ->
	could vectorize more ops if space | num -> any ->
	2** (auto 8) (if space) | int/num ->

list
	takeWhile / dropWhile / span | [any] -> fn ->
	splitAt | num -> [any] ->
	split, keep empties | [a] -> [a] ->
	intersperse | a -> [a] -> (intercalate could be useful too)
	group by
	indices [by]
	setwise uniq / xor / or / and (operate on first of tuples for [by]), keep multiples, that way can use uniq if don't want
	zip prevs

str
	str= more useful than list=
	l/rjust (rjust more common in gs2)
	down/upcase (if space)
	tbd

chr
	tbd

misc
	autorec (base case and cond = $) (or maybe version) (skip for now.. how often really needed)
	nats (if needed...)

