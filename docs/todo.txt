clarify fn0/etc (num rets)
fold on prefixes (primo)
	1 op folds, 1 char shorter using non matching string/int constants
put rep in arg list instead of using istildastart

simple mode (and simplify quickref)
better checking for commutative, taking into account what the code would be if swapping order with lets

consider that extensions may make other extensions codes not useless
	?rs 1"...a.."~ a/$$
	is an example of this
also using an auto variable when it isn't available needs a check
ideally could detect these automatically and check for possible collisions (maybe foreach on most common types)

: really should be revamped to allow easier tuple construction but its complicated
	should accept fn as first arg
	singleton needs auto value from second arg, but this is hard because first arg fn breaks arg matching after (need to revamp convertop)
(this could also allow for 2nd arg to if/else to be Default value (coerced 0 tuple)
	abs needs to be something else
		-after can revert hacky stuff from https://github.com/darrenks/nibbles/commit/9eccacbd5c4d0e3a4f256a7e33e29630f457543a
	delete cons, instead have special way to create list of strings
	if : with first value as a tuple then number of rets for second arg should match unless it is a list of a tuple

For alpha release:
-more extensions

debug features to add:
	gather rest of program
	show context values
	verbose literate mode (and/or print tree) (with arg names, types, desc, indentation)
	see parse tree

minor things:
-maybe
-use of char (and instances to convert for vec)
-write a how page / document code
-" " instead of "\n" in auto map inner separator

------------------------------------------
should also have dependency bounds for dlist/etc.
-------------------------------
auto input types (for command line args, use delims for list of ints)
library reference?

non empty list for many [VT] for type safer haskell in compiler

fyi instead of coerce in user fn, could skip it in context lookup

for multipage quickref (coerce, etc)
https://stackoverflow.com/questions/1664049/can-i-force-a-page-break-in-html-printing

website design art

ParseError in parse instead of regular (need refactor to monad)

better op not found error message (hard because memoize of arg types is lazy)

either instead of bool/maybe
maybe id, maybe nothing
handle div 0 errors/etc
infinity, iden init val

index/prev in loop

quickref to show return types

switch to integer and char everywhere
bounded integers/list size for more efficient math ops and no need for maybe on some list ops
could support parenthesis that do nothing but cause error if parse isn't as expected
also could support named lambdas/assignments that get converted into debruijns
interpret instead of compile

interpreter in addition to compiler (auto build it?)